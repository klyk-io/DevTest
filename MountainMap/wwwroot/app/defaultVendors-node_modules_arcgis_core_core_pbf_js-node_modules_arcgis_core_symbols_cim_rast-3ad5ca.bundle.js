"use strict";
(self["webpackChunkmm"] = self["webpackChunkmm"] || []).push([["defaultVendors-node_modules_arcgis_core_core_pbf_js-node_modules_arcgis_core_symbols_cim_rast-3ad5ca"],{

/***/ "./node_modules/@arcgis/core/core/pbf.js":
/*!***********************************************!*\
  !*** ./node_modules/@arcgis/core/core/pbf.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _ObjectPool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectPool.js */ "./node_modules/@arcgis/core/core/ObjectPool.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
var e;!function(t){t[t.varint=0]="varint",t[t.fixed64=1]="fixed64",t[t.delimited=2]="delimited",t[t.fixed32=5]="fixed32",t[t.unknown=99]="unknown"}(e||(e={}));const i=4294967296,s=new TextDecoder("utf-8"),n=(0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("safari")||(0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("ios")?6:(0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("ff")?12:32;class r{constructor(t,i,s=0,n=(t?t.byteLength:0)){this._tag=0,this._dataType=e.unknown,this._init(t,i,s,n)}_init(t,e,i,s){this._data=t,this._dataView=e,this._pos=i,this._end=s}asUnsafe(){return this}clone(){return new r(this._data,this._dataView,this._pos,this._end)}pos(){return this._pos}move(t){this._pos=t}nextTag(t){for(;;){if(this._pos===this._end)return!1;const e=this._decodeVarint();if(this._tag=e>>3,this._dataType=7&e,!t||t===this._tag)break;this.skip()}return!0}next(){if(this._pos===this._end)return!1;const t=this._decodeVarint();return this._tag=t>>3,this._dataType=7&t,!0}empty(){return this._pos>=this._end}tag(){return this._tag}getInt32(){return this._decodeVarint()}getInt64(){return this._decodeVarint()}getUInt32(){let t=4294967295;return t=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128?t:(t=(t|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128?t:(t=(t|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128?t:(t=(t|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128?t:(t=(t|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128?t:void 0))))}getUInt64(){return this._decodeVarint()}getSInt32(){const t=this.getUInt32();if(void 0!==t)return t>>>1^-(1&t)|0}getSInt64(){return this._decodeSVarint()}getBool(){const t=0!==this._data[this._pos];return this._skip(1),t}getEnum(){return this._decodeVarint()}getFixed64(){const t=this._dataView,e=this._pos,s=t.getUint32(e,!0)+t.getUint32(e+4,!0)*i;return this._skip(8),s}getSFixed64(){const t=this._dataView,e=this._pos,s=t.getUint32(e,!0)+t.getInt32(e+4,!0)*i;return this._skip(8),s}getDouble(){const t=this._dataView.getFloat64(this._pos,!0);return this._skip(8),t}getFixed32(){const t=this._dataView.getUint32(this._pos,!0);return this._skip(4),t}getSFixed32(){const t=this._dataView.getInt32(this._pos,!0);return this._skip(4),t}getFloat(){const t=this._dataView.getFloat32(this._pos,!0);return this._skip(4),t}getString(){const t=this._getLength(),e=this._pos,i=this._toString(this._data,e,e+t);return this._skip(t),i}getBytes(){const t=this._getLength(),e=this._pos,i=this._toBytes(this._data,e,e+t);return this._skip(t),i}getLength(){return this._getLengthUnsafe()}processMessageWithArgs(t,e,i,s){const n=this.getMessage(),r=t(n,e,i,s);return n.release(),r}processMessage(t){const e=this.getMessage(),i=t(e);return e.release(),i}getMessage(){const t=this._getLength(),e=r.pool.acquire();return e._init(this._data,this._dataView,this._pos,this._pos+t),this._skip(t),e}release(){r.pool.release(this)}dataType(){return this._dataType}skip(){switch(this._dataType){case e.varint:this._decodeVarint();break;case e.fixed64:this._skip(8);break;case e.delimited:this._skip(this._getLength());break;case e.fixed32:this._skip(4);break;default:throw new Error("Invalid data type!")}}skipLen(t){this._skip(t)}_skip(t){if(this._pos+t>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=t}_decodeVarint(){const t=this._data;let e=this._pos,i=0,s=0;if(this._end-e>=10)do{if(s=t[e++],i|=127&s,0==(128&s))break;if(s=t[e++],i|=(127&s)<<7,0==(128&s))break;if(s=t[e++],i|=(127&s)<<14,0==(128&s))break;if(s=t[e++],i|=(127&s)<<21,0==(128&s))break;if(s=t[e++],i+=268435456*(127&s),0==(128&s))break;if(s=t[e++],i+=34359738368*(127&s),0==(128&s))break;if(s=t[e++],i+=4398046511104*(127&s),0==(128&s))break;if(s=t[e++],i+=562949953421312*(127&s),0==(128&s))break;if(s=t[e++],i+=72057594037927940*(127&s),0==(128&s))break;if(s=t[e++],i+=0x8000000000000000*(127&s),0==(128&s))break;throw new Error("Varint too long!")}while(0);else{let n=1;for(;e!==this._end&&(s=t[e],0!=(128&s));)++e,i+=(127&s)*n,n*=128;if(e===this._end)throw new Error("Varint overrun!");++e,i+=s*n}return this._pos=e,i}_decodeSVarint(){const t=this._data;let e,i=0,s=0;const n=1&t[this._pos];if(s=t[this._pos++],i|=127&s,0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i|=(127&s)<<7,0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i|=(127&s)<<14,0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i|=(127&s)<<21,0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i+=268435456*(127&s),0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i+=34359738368*(127&s),0==(128&s))return n?-(i+1)/2:i/2;if(s=t[this._pos++],i+=4398046511104*(127&s),0==(128&s))return n?-(i+1)/2:i/2;if(e=BigInt(i),s=t[this._pos++],e+=0x2000000000000n*BigInt(127&s),0==(128&s))return Number(n?-(e+1n)/2n:e/2n);if(s=t[this._pos++],e+=0x100000000000000n*BigInt(127&s),0==(128&s))return Number(n?-(e+1n)/2n:e/2n);if(s=t[this._pos++],e+=0x8000000000000000n*BigInt(127&s),0==(128&s))return Number(n?-(e+1n)/2n:e/2n);throw new Error("Varint too long!")}_getLength(){if(this._dataType!==e.delimited)throw new Error("Not a delimited data type!");return this._decodeVarint()}_getLengthUnsafe(){return this.getUInt32()}_toString(t,e,i){if((i=Math.min(this._end,i))-e>n){const n=t.subarray(e,i);return s.decode(n)}let r="",h="";for(let s=e;s<i;++s){const e=t[s];128&e?h+="%"+e.toString(16):(r+=decodeURIComponent(h)+String.fromCharCode(e),h="")}return h.length&&(r+=decodeURIComponent(h)),r}_toBytes(t,e,i){return i=Math.min(this._end,i),new Uint8Array(t.buffer,e,i-e)}}r.pool=new _ObjectPool_js__WEBPACK_IMPORTED_MODULE_1__["default"](r,void 0,(t=>{t._data=null,t._dataView=null}));


/***/ }),

/***/ "./node_modules/@arcgis/core/symbols/cim/rasterizingUtils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@arcgis/core/symbols/cim/rasterizingUtils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rasterizeDash: () => (/* binding */ e),
/* harmony export */   rasterizeSimpleFill: () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _core_floatRGBA_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/floatRGBA.js */ "./node_modules/@arcgis/core/core/floatRGBA.js");
/* harmony import */ var _core_mathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/mathUtils.js */ "./node_modules/@arcgis/core/core/mathUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
const a=o=>"vertical"===o||"horizontal"===o||"cross"===o||"esriSFSCross"===o||"esriSFSVertical"===o||"esriSFSHorizontal"===o;function r(o,r,e){const i=(0,_core_mathUtils_js__WEBPACK_IMPORTED_MODULE_1__.nextPowerOfTwo)(Math.ceil(e)),n=a(r)?8*i:16*i,s=2*i;o.width=n,o.height=n;const l=o.getContext("2d");l.strokeStyle="#FFFFFF",l.lineWidth=i,l.beginPath(),"vertical"!==r&&"cross"!==r&&"esriSFSCross"!==r&&"esriSFSVertical"!==r||(l.moveTo(n/2,-s),l.lineTo(n/2,n+s)),"horizontal"!==r&&"cross"!==r&&"esriSFSCross"!==r&&"esriSFSHorizontal"!==r||(l.moveTo(-s,n/2),l.lineTo(n+s,n/2)),"forward-diagonal"!==r&&"diagonal-cross"!==r&&"esriSFSDiagonalCross"!==r&&"esriSFSForwardDiagonal"!==r||(l.moveTo(-s,-s),l.lineTo(n+s,n+s),l.moveTo(n-s,-s),l.lineTo(n+s,s),l.moveTo(-s,n-s),l.lineTo(s,n+s)),"backward-diagonal"!==r&&"diagonal-cross"!==r&&"esriSFSBackwardDiagonal"!==r&&"esriSFSDiagonalCross"!==r||(l.moveTo(n+s,-s),l.lineTo(-s,n+s),l.moveTo(s,-s),l.lineTo(-s,s),l.moveTo(n+s,n-s),l.lineTo(n-s,n+s)),l.stroke();const h=l.getImageData(0,0,o.width,o.height),c=new Uint8Array(h.data);let m;for(let t=0;t<c.length;t+=4)m=c[t+3]/255,c[t]=c[t]*m,c[t+1]=c[t+1]*m,c[t+2]=c[t+2]*m;return[c,o.width,o.height]}function e(t,a){const r="Butt"===a,e="Square"===a,i=!r&&!e;t.length%2==1&&(t=[...t,...t]);const n=15.5,s=2*n;let l=0;for(const o of t)l+=o;const h=Math.round(l*n),c=new Float32Array(h*s),m=.5*n;let S=0,F=0,g=.5,T=!0;for(const o of t){for(S=F,F+=o*n;g<=F;){let o=.5;for(;o<s;){const t=(o-.5)*h+g-.5,a=i?(o-n)*(o-n):Math.abs(o-n);c[t]=T?r?Math.max(Math.max(S+m-g,a),Math.max(g-F+m,a)):a:i?Math.min((g-S)*(g-S)+a,(g-F)*(g-F)+a):e?Math.min(Math.max(g-S,a),Math.max(F-g,a)):Math.min(Math.max(g-S+m,a),Math.max(F+m-g,a)),o++}g++}T=!T}const d=c.length,f=new Uint8Array(4*d);for(let M=0;M<d;++M){const t=(i?Math.sqrt(c[M]):c[M])/n;(0,_core_floatRGBA_js__WEBPACK_IMPORTED_MODULE_0__.packFloatRGBA)(t,f,4*M)}return[f,h,s]}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveIncludes: () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaderRepository.js */ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js");
/* harmony import */ var _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../webgl/ShaderCompiler.js */ "./node_modules/@arcgis/core/views/webgl/ShaderCompiler.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
function o(e){let o=_shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__["default"];return e.split("/").forEach((r=>{o&&(o=o[r])})),o}const t=new _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__.ShaderCompiler(o);function n(r){return t.resolveIncludes(r)}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
const e={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdFZlbmRvcnMtbm9kZV9tb2R1bGVzX2FyY2dpc19jb3JlX2NvcmVfcGJmX2pzLW5vZGVfbW9kdWxlc19hcmNnaXNfY29yZV9zeW1ib2xzX2NpbV9yYXN0LTNhZDVjYS5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUQsTUFBTSxhQUFhLGdJQUFnSSxTQUFTLEdBQUcsZ0RBQWdELG1EQUFHLFlBQVksbURBQUcsVUFBVSxtREFBRyxhQUFhLFFBQVEsMENBQTBDLHlEQUF5RCxlQUFlLHNEQUFzRCxXQUFXLFlBQVksUUFBUSw0REFBNEQsTUFBTSxpQkFBaUIsUUFBUSxZQUFZLFdBQVcsTUFBTSxFQUFFLGtDQUFrQyw2QkFBNkIsNkRBQTZELFlBQVksU0FBUyxPQUFPLGtDQUFrQyw2QkFBNkIsNENBQTRDLFFBQVEsNEJBQTRCLE1BQU0saUJBQWlCLFdBQVcsNEJBQTRCLFdBQVcsNEJBQTRCLFlBQVksaUJBQWlCLG9YQUFvWCxZQUFZLDRCQUE0QixZQUFZLHlCQUF5QixvQ0FBb0MsWUFBWSw2QkFBNkIsVUFBVSxrQ0FBa0MsdUJBQXVCLFVBQVUsNEJBQTRCLGFBQWEsNkVBQTZFLHVCQUF1QixjQUFjLDRFQUE0RSx1QkFBdUIsWUFBWSxnREFBZ0QsdUJBQXVCLGFBQWEsK0NBQStDLHVCQUF1QixjQUFjLDhDQUE4Qyx1QkFBdUIsV0FBVyxnREFBZ0QsdUJBQXVCLFlBQVkseUVBQXlFLHVCQUF1QixXQUFXLHdFQUF3RSx1QkFBdUIsWUFBWSwrQkFBK0IsZ0NBQWdDLHVDQUF1QyxxQkFBcUIsa0JBQWtCLGlDQUFpQyxxQkFBcUIsYUFBYSw2Q0FBNkMsZ0ZBQWdGLFVBQVUscUJBQXFCLFdBQVcsc0JBQXNCLE9BQU8sdUJBQXVCLG1DQUFtQyxNQUFNLDZCQUE2QixNQUFNLCtDQUErQyxNQUFNLDZCQUE2QixNQUFNLCtDQUErQyxXQUFXLGNBQWMsU0FBUyxvRkFBb0YsYUFBYSxnQkFBZ0IsbUJBQW1CLHdC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QUE4Qiw0REFBNEQsdUNBQXVDLGtIQUFrSCxHQUFHLFNBQVMsa0hBQWtILEdBQUcsNkNBQTZDLHVDQUF1QyxtQ0FBbUMsa0NBQWtDLGlDQUFpQyx1REFBdUQseURBQXlELHlMQUF5TCxxREFBcUQsR0FBRyxFQUFFLE9BQU8saUxBQWlMLCtCQUErQix1Q0FBdUMsR0FBRywwQ0FBMEMsc0NBQXNDLEdBQUcsSUFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tbS8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvY29yZS9wYmYuanMiLCJ3ZWJwYWNrOi8vbW0vLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3N5bWJvbHMvY2ltL3Jhc3Rlcml6aW5nVXRpbHMuanMiLCJ3ZWJwYWNrOi8vbW0vLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS92ZWN0b3JUaWxlcy9zaGFkZXJzL3NvdXJjZXMvcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vbW0vLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS92ZWN0b3JUaWxlcy9zaGFkZXJzL3NvdXJjZXMvc2hhZGVyUmVwb3NpdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yOC9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IGhhcyBmcm9tXCIuL2hhcy5qc1wiO2ltcG9ydCB0IGZyb21cIi4vT2JqZWN0UG9vbC5qc1wiO3ZhciBlOyFmdW5jdGlvbih0KXt0W3QudmFyaW50PTBdPVwidmFyaW50XCIsdFt0LmZpeGVkNjQ9MV09XCJmaXhlZDY0XCIsdFt0LmRlbGltaXRlZD0yXT1cImRlbGltaXRlZFwiLHRbdC5maXhlZDMyPTVdPVwiZml4ZWQzMlwiLHRbdC51bmtub3duPTk5XT1cInVua25vd25cIn0oZXx8KGU9e30pKTtjb25zdCBpPTQyOTQ5NjcyOTYscz1uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKSxuPWhhcyhcInNhZmFyaVwiKXx8aGFzKFwiaW9zXCIpPzY6aGFzKFwiZmZcIik/MTI6MzI7Y2xhc3Mgcntjb25zdHJ1Y3Rvcih0LGkscz0wLG49KHQ/dC5ieXRlTGVuZ3RoOjApKXt0aGlzLl90YWc9MCx0aGlzLl9kYXRhVHlwZT1lLnVua25vd24sdGhpcy5faW5pdCh0LGkscyxuKX1faW5pdCh0LGUsaSxzKXt0aGlzLl9kYXRhPXQsdGhpcy5fZGF0YVZpZXc9ZSx0aGlzLl9wb3M9aSx0aGlzLl9lbmQ9c31hc1Vuc2FmZSgpe3JldHVybiB0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyByKHRoaXMuX2RhdGEsdGhpcy5fZGF0YVZpZXcsdGhpcy5fcG9zLHRoaXMuX2VuZCl9cG9zKCl7cmV0dXJuIHRoaXMuX3Bvc31tb3ZlKHQpe3RoaXMuX3Bvcz10fW5leHRUYWcodCl7Zm9yKDs7KXtpZih0aGlzLl9wb3M9PT10aGlzLl9lbmQpcmV0dXJuITE7Y29uc3QgZT10aGlzLl9kZWNvZGVWYXJpbnQoKTtpZih0aGlzLl90YWc9ZT4+Myx0aGlzLl9kYXRhVHlwZT03JmUsIXR8fHQ9PT10aGlzLl90YWcpYnJlYWs7dGhpcy5za2lwKCl9cmV0dXJuITB9bmV4dCgpe2lmKHRoaXMuX3Bvcz09PXRoaXMuX2VuZClyZXR1cm4hMTtjb25zdCB0PXRoaXMuX2RlY29kZVZhcmludCgpO3JldHVybiB0aGlzLl90YWc9dD4+Myx0aGlzLl9kYXRhVHlwZT03JnQsITB9ZW1wdHkoKXtyZXR1cm4gdGhpcy5fcG9zPj10aGlzLl9lbmR9dGFnKCl7cmV0dXJuIHRoaXMuX3RhZ31nZXRJbnQzMigpe3JldHVybiB0aGlzLl9kZWNvZGVWYXJpbnQoKX1nZXRJbnQ2NCgpe3JldHVybiB0aGlzLl9kZWNvZGVWYXJpbnQoKX1nZXRVSW50MzIoKXtsZXQgdD00Mjk0OTY3Mjk1O3JldHVybiB0PSgxMjcmdGhpcy5fZGF0YVt0aGlzLl9wb3NdKT4+PjAsdGhpcy5fZGF0YVt0aGlzLl9wb3MrK108MTI4P3Q6KHQ9KHR8KDEyNyZ0aGlzLl9kYXRhW3RoaXMuX3Bvc10pPDw3KT4+PjAsdGhpcy5fZGF0YVt0aGlzLl9wb3MrK108MTI4P3Q6KHQ9KHR8KDEyNyZ0aGlzLl9kYXRhW3RoaXMuX3Bvc10pPDwxNCk+Pj4wLHRoaXMuX2RhdGFbdGhpcy5fcG9zKytdPDEyOD90Oih0PSh0fCgxMjcmdGhpcy5fZGF0YVt0aGlzLl9wb3NdKTw8MjEpPj4+MCx0aGlzLl9kYXRhW3RoaXMuX3BvcysrXTwxMjg/dDoodD0odHwoMTUmdGhpcy5fZGF0YVt0aGlzLl9wb3NdKTw8MjgpPj4+MCx0aGlzLl9kYXRhW3RoaXMuX3BvcysrXTwxMjg/dDp2b2lkIDApKSkpfWdldFVJbnQ2NCgpe3JldHVybiB0aGlzLl9kZWNvZGVWYXJpbnQoKX1nZXRTSW50MzIoKXtjb25zdCB0PXRoaXMuZ2V0VUludDMyKCk7aWYodm9pZCAwIT09dClyZXR1cm4gdD4+PjFeLSgxJnQpfDB9Z2V0U0ludDY0KCl7cmV0dXJuIHRoaXMuX2RlY29kZVNWYXJpbnQoKX1nZXRCb29sKCl7Y29uc3QgdD0wIT09dGhpcy5fZGF0YVt0aGlzLl9wb3NdO3JldHVybiB0aGlzLl9za2lwKDEpLHR9Z2V0RW51bSgpe3JldHVybiB0aGlzLl9kZWNvZGVWYXJpbnQoKX1nZXRGaXhlZDY0KCl7Y29uc3QgdD10aGlzLl9kYXRhVmlldyxlPXRoaXMuX3BvcyxzPXQuZ2V0VWludDMyKGUsITApK3QuZ2V0VWludDMyKGUrNCwhMCkqaTtyZXR1cm4gdGhpcy5fc2tpcCg4KSxzfWdldFNGaXhlZDY0KCl7Y29uc3QgdD10aGlzLl9kYXRhVmlldyxlPXRoaXMuX3BvcyxzPXQuZ2V0VWludDMyKGUsITApK3QuZ2V0SW50MzIoZSs0LCEwKSppO3JldHVybiB0aGlzLl9za2lwKDgpLHN9Z2V0RG91YmxlKCl7Y29uc3QgdD10aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KHRoaXMuX3BvcywhMCk7cmV0dXJuIHRoaXMuX3NraXAoOCksdH1nZXRGaXhlZDMyKCl7Y29uc3QgdD10aGlzLl9kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fcG9zLCEwKTtyZXR1cm4gdGhpcy5fc2tpcCg0KSx0fWdldFNGaXhlZDMyKCl7Y29uc3QgdD10aGlzLl9kYXRhVmlldy5nZXRJbnQzMih0aGlzLl9wb3MsITApO3JldHVybiB0aGlzLl9za2lwKDQpLHR9Z2V0RmxvYXQoKXtjb25zdCB0PXRoaXMuX2RhdGFWaWV3LmdldEZsb2F0MzIodGhpcy5fcG9zLCEwKTtyZXR1cm4gdGhpcy5fc2tpcCg0KSx0fWdldFN0cmluZygpe2NvbnN0IHQ9dGhpcy5fZ2V0TGVuZ3RoKCksZT10aGlzLl9wb3MsaT10aGlzLl90b1N0cmluZyh0aGlzLl9kYXRhLGUsZSt0KTtyZXR1cm4gdGhpcy5fc2tpcCh0KSxpfWdldEJ5dGVzKCl7Y29uc3QgdD10aGlzLl9nZXRMZW5ndGgoKSxlPXRoaXMuX3BvcyxpPXRoaXMuX3RvQnl0ZXModGhpcy5fZGF0YSxlLGUrdCk7cmV0dXJuIHRoaXMuX3NraXAodCksaX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5fZ2V0TGVuZ3RoVW5zYWZlKCl9cHJvY2Vzc01lc3NhZ2VXaXRoQXJncyh0LGUsaSxzKXtjb25zdCBuPXRoaXMuZ2V0TWVzc2FnZSgpLHI9dChuLGUsaSxzKTtyZXR1cm4gbi5yZWxlYXNlKCkscn1wcm9jZXNzTWVzc2FnZSh0KXtjb25zdCBlPXRoaXMuZ2V0TWVzc2FnZSgpLGk9dChlKTtyZXR1cm4gZS5yZWxlYXNlKCksaX1nZXRNZXNzYWdlKCl7Y29uc3QgdD10aGlzLl9nZXRMZW5ndGgoKSxlPXIucG9vbC5hY3F1aXJlKCk7cmV0dXJuIGUuX2luaXQodGhpcy5fZGF0YSx0aGlzLl9kYXRhVmlldyx0aGlzLl9wb3MsdGhpcy5fcG9zK3QpLHRoaXMuX3NraXAodCksZX1yZWxlYXNlKCl7ci5wb29sLnJlbGVhc2UodGhpcyl9ZGF0YVR5cGUoKXtyZXR1cm4gdGhpcy5fZGF0YVR5cGV9c2tpcCgpe3N3aXRjaCh0aGlzLl9kYXRhVHlwZSl7Y2FzZSBlLnZhcmludDp0aGlzLl9kZWNvZGVWYXJpbnQoKTticmVhaztjYXNlIGUuZml4ZWQ2NDp0aGlzLl9za2lwKDgpO2JyZWFrO2Nhc2UgZS5kZWxpbWl0ZWQ6dGhpcy5fc2tpcCh0aGlzLl9nZXRMZW5ndGgoKSk7YnJlYWs7Y2FzZSBlLmZpeGVkMzI6dGhpcy5fc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlIVwiKX19c2tpcExlbih0KXt0aGlzLl9za2lwKHQpfV9za2lwKHQpe2lmKHRoaXMuX3Bvcyt0PnRoaXMuX2VuZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0IHRvIHNraXAgcGFzdCB0aGUgZW5kIG9mIGJ1ZmZlciFcIik7dGhpcy5fcG9zKz10fV9kZWNvZGVWYXJpbnQoKXtjb25zdCB0PXRoaXMuX2RhdGE7bGV0IGU9dGhpcy5fcG9zLGk9MCxzPTA7aWYodGhpcy5fZW5kLWU+PTEwKWRve2lmKHM9dFtlKytdLGl8PTEyNyZzLDA9PSgxMjgmcykpYnJlYWs7aWYocz10W2UrK10saXw9KDEyNyZzKTw8NywwPT0oMTI4JnMpKWJyZWFrO2lmKHM9dFtlKytdLGl8PSgxMjcmcyk8PDE0LDA9PSgxMjgmcykpYnJlYWs7aWYocz10W2UrK10saXw9KDEyNyZzKTw8MjEsMD09KDEyOCZzKSlicmVhaztpZihzPXRbZSsrXSxpKz0yNjg0MzU0NTYqKDEyNyZzKSwwPT0oMTI4JnMpKWJyZWFrO2lmKHM9dFtlKytdLGkrPTM0MzU5NzM4MzY4KigxMjcmcyksMD09KDEyOCZzKSlicmVhaztpZihzPXRbZSsrXSxpKz00Mzk4MDQ2NTExMTA0KigxMjcmcyksMD09KDEyOCZzKSlicmVhaztpZihzPXRbZSsrXSxpKz01NjI5NDk5NTM0MjEzMTIqKDEyNyZzKSwwPT0oMTI4JnMpKWJyZWFrO2lmKHM9dFtlKytdLGkrPTcyMDU3NTk0MDM3OTI3OTQwKigxMjcmcyksMD09KDEyOCZzKSlicmVhaztpZihzPXRbZSsrXSxpKz0weDgwMDAwMDAwMDAwMDAwMDAqKDEyNyZzKSwwPT0oMTI4JnMpKWJyZWFrO3Rocm93IG5ldyBFcnJvcihcIlZhcmludCB0b28gbG9uZyFcIil9d2hpbGUoMCk7ZWxzZXtsZXQgbj0xO2Zvcig7ZSE9PXRoaXMuX2VuZCYmKHM9dFtlXSwwIT0oMTI4JnMpKTspKytlLGkrPSgxMjcmcykqbixuKj0xMjg7aWYoZT09PXRoaXMuX2VuZCl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpbnQgb3ZlcnJ1biFcIik7KytlLGkrPXMqbn1yZXR1cm4gdGhpcy5fcG9zPWUsaX1fZGVjb2RlU1ZhcmludCgpe2NvbnN0IHQ9dGhpcy5fZGF0YTtsZXQgZSxpPTAscz0wO2NvbnN0IG49MSZ0W3RoaXMuX3Bvc107aWYocz10W3RoaXMuX3BvcysrXSxpfD0xMjcmcywwPT0oMTI4JnMpKXJldHVybiBuPy0oaSsxKS8yOmkvMjtpZihzPXRbdGhpcy5fcG9zKytdLGl8PSgxMjcmcyk8PDcsMD09KDEyOCZzKSlyZXR1cm4gbj8tKGkrMSkvMjppLzI7aWYocz10W3RoaXMuX3BvcysrXSxpfD0oMTI3JnMpPDwxNCwwPT0oMTI4JnMpKXJldHVybiBuPy0oaSsxKS8yOmkvMjtpZihzPXRbdGhpcy5fcG9zKytdLGl8PSgxMjcmcyk8PDIxLDA9PSgxMjgmcykpcmV0dXJuIG4/LShpKzEpLzI6aS8yO2lmKHM9dFt0aGlzLl9wb3MrK10saSs9MjY4NDM1NDU2KigxMjcmcyksMD09KDEyOCZzKSlyZXR1cm4gbj8tKGkrMSkvMjppLzI7aWYocz10W3RoaXMuX3BvcysrXSxpKz0zNDM1OTczODM2OCooMTI3JnMpLDA9PSgxMjgmcykpcmV0dXJuIG4/LShpKzEpLzI6aS8yO2lmKHM9dFt0aGlzLl9wb3MrK10saSs9NDM5ODA0NjUxMTEwNCooMTI3JnMpLDA9PSgxMjgmcykpcmV0dXJuIG4/LShpKzEpLzI6aS8yO2lmKGU9QmlnSW50KGkpLHM9dFt0aGlzLl9wb3MrK10sZSs9MHgyMDAwMDAwMDAwMDAwbipCaWdJbnQoMTI3JnMpLDA9PSgxMjgmcykpcmV0dXJuIE51bWJlcihuPy0oZSsxbikvMm46ZS8ybik7aWYocz10W3RoaXMuX3BvcysrXSxlKz0weDEwMDAwMDAwMDAwMDAwMG4qQmlnSW50KDEyNyZzKSwwPT0oMTI4JnMpKXJldHVybiBOdW1iZXIobj8tKGUrMW4pLzJuOmUvMm4pO2lmKHM9dFt0aGlzLl9wb3MrK10sZSs9MHg4MDAwMDAwMDAwMDAwMDAwbipCaWdJbnQoMTI3JnMpLDA9PSgxMjgmcykpcmV0dXJuIE51bWJlcihuPy0oZSsxbikvMm46ZS8ybik7dGhyb3cgbmV3IEVycm9yKFwiVmFyaW50IHRvbyBsb25nIVwiKX1fZ2V0TGVuZ3RoKCl7aWYodGhpcy5fZGF0YVR5cGUhPT1lLmRlbGltaXRlZCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBkZWxpbWl0ZWQgZGF0YSB0eXBlIVwiKTtyZXR1cm4gdGhpcy5fZGVjb2RlVmFyaW50KCl9X2dldExlbmd0aFVuc2FmZSgpe3JldHVybiB0aGlzLmdldFVJbnQzMigpfV90b1N0cmluZyh0LGUsaSl7aWYoKGk9TWF0aC5taW4odGhpcy5fZW5kLGkpKS1lPm4pe2NvbnN0IG49dC5zdWJhcnJheShlLGkpO3JldHVybiBzLmRlY29kZShuKX1sZXQgcj1cIlwiLGg9XCJcIjtmb3IobGV0IHM9ZTtzPGk7KytzKXtjb25zdCBlPXRbc107MTI4JmU/aCs9XCIlXCIrZS50b1N0cmluZygxNik6KHIrPWRlY29kZVVSSUNvbXBvbmVudChoKStTdHJpbmcuZnJvbUNoYXJDb2RlKGUpLGg9XCJcIil9cmV0dXJuIGgubGVuZ3RoJiYocis9ZGVjb2RlVVJJQ29tcG9uZW50KGgpKSxyfV90b0J5dGVzKHQsZSxpKXtyZXR1cm4gaT1NYXRoLm1pbih0aGlzLl9lbmQsaSksbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsZSxpLWUpfX1yLnBvb2w9bmV3IHQocix2b2lkIDAsKHQ9Pnt0Ll9kYXRhPW51bGwsdC5fZGF0YVZpZXc9bnVsbH0pKTtleHBvcnR7ciBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI4L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7cGFja0Zsb2F0UkdCQSBhcyBvfWZyb21cIi4uLy4uL2NvcmUvZmxvYXRSR0JBLmpzXCI7aW1wb3J0e25leHRQb3dlck9mVHdvIGFzIHR9ZnJvbVwiLi4vLi4vY29yZS9tYXRoVXRpbHMuanNcIjtjb25zdCBhPW89PlwidmVydGljYWxcIj09PW98fFwiaG9yaXpvbnRhbFwiPT09b3x8XCJjcm9zc1wiPT09b3x8XCJlc3JpU0ZTQ3Jvc3NcIj09PW98fFwiZXNyaVNGU1ZlcnRpY2FsXCI9PT1vfHxcImVzcmlTRlNIb3Jpem9udGFsXCI9PT1vO2Z1bmN0aW9uIHIobyxyLGUpe2NvbnN0IGk9dChNYXRoLmNlaWwoZSkpLG49YShyKT84Kmk6MTYqaSxzPTIqaTtvLndpZHRoPW4sby5oZWlnaHQ9bjtjb25zdCBsPW8uZ2V0Q29udGV4dChcIjJkXCIpO2wuc3Ryb2tlU3R5bGU9XCIjRkZGRkZGXCIsbC5saW5lV2lkdGg9aSxsLmJlZ2luUGF0aCgpLFwidmVydGljYWxcIiE9PXImJlwiY3Jvc3NcIiE9PXImJlwiZXNyaVNGU0Nyb3NzXCIhPT1yJiZcImVzcmlTRlNWZXJ0aWNhbFwiIT09cnx8KGwubW92ZVRvKG4vMiwtcyksbC5saW5lVG8obi8yLG4rcykpLFwiaG9yaXpvbnRhbFwiIT09ciYmXCJjcm9zc1wiIT09ciYmXCJlc3JpU0ZTQ3Jvc3NcIiE9PXImJlwiZXNyaVNGU0hvcml6b250YWxcIiE9PXJ8fChsLm1vdmVUbygtcyxuLzIpLGwubGluZVRvKG4rcyxuLzIpKSxcImZvcndhcmQtZGlhZ29uYWxcIiE9PXImJlwiZGlhZ29uYWwtY3Jvc3NcIiE9PXImJlwiZXNyaVNGU0RpYWdvbmFsQ3Jvc3NcIiE9PXImJlwiZXNyaVNGU0ZvcndhcmREaWFnb25hbFwiIT09cnx8KGwubW92ZVRvKC1zLC1zKSxsLmxpbmVUbyhuK3MsbitzKSxsLm1vdmVUbyhuLXMsLXMpLGwubGluZVRvKG4rcyxzKSxsLm1vdmVUbygtcyxuLXMpLGwubGluZVRvKHMsbitzKSksXCJiYWNrd2FyZC1kaWFnb25hbFwiIT09ciYmXCJkaWFnb25hbC1jcm9zc1wiIT09ciYmXCJlc3JpU0ZTQmFja3dhcmREaWFnb25hbFwiIT09ciYmXCJlc3JpU0ZTRGlhZ29uYWxDcm9zc1wiIT09cnx8KGwubW92ZVRvKG4rcywtcyksbC5saW5lVG8oLXMsbitzKSxsLm1vdmVUbyhzLC1zKSxsLmxpbmVUbygtcyxzKSxsLm1vdmVUbyhuK3Msbi1zKSxsLmxpbmVUbyhuLXMsbitzKSksbC5zdHJva2UoKTtjb25zdCBoPWwuZ2V0SW1hZ2VEYXRhKDAsMCxvLndpZHRoLG8uaGVpZ2h0KSxjPW5ldyBVaW50OEFycmF5KGguZGF0YSk7bGV0IG07Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0Kz00KW09Y1t0KzNdLzI1NSxjW3RdPWNbdF0qbSxjW3QrMV09Y1t0KzFdKm0sY1t0KzJdPWNbdCsyXSptO3JldHVybltjLG8ud2lkdGgsby5oZWlnaHRdfWZ1bmN0aW9uIGUodCxhKXtjb25zdCByPVwiQnV0dFwiPT09YSxlPVwiU3F1YXJlXCI9PT1hLGk9IXImJiFlO3QubGVuZ3RoJTI9PTEmJih0PVsuLi50LC4uLnRdKTtjb25zdCBuPTE1LjUscz0yKm47bGV0IGw9MDtmb3IoY29uc3QgbyBvZiB0KWwrPW87Y29uc3QgaD1NYXRoLnJvdW5kKGwqbiksYz1uZXcgRmxvYXQzMkFycmF5KGgqcyksbT0uNSpuO2xldCBTPTAsRj0wLGc9LjUsVD0hMDtmb3IoY29uc3QgbyBvZiB0KXtmb3IoUz1GLEYrPW8qbjtnPD1GOyl7bGV0IG89LjU7Zm9yKDtvPHM7KXtjb25zdCB0PShvLS41KSpoK2ctLjUsYT1pPyhvLW4pKihvLW4pOk1hdGguYWJzKG8tbik7Y1t0XT1UP3I/TWF0aC5tYXgoTWF0aC5tYXgoUyttLWcsYSksTWF0aC5tYXgoZy1GK20sYSkpOmE6aT9NYXRoLm1pbigoZy1TKSooZy1TKSthLChnLUYpKihnLUYpK2EpOmU/TWF0aC5taW4oTWF0aC5tYXgoZy1TLGEpLE1hdGgubWF4KEYtZyxhKSk6TWF0aC5taW4oTWF0aC5tYXgoZy1TK20sYSksTWF0aC5tYXgoRittLWcsYSkpLG8rK31nKyt9VD0hVH1jb25zdCBkPWMubGVuZ3RoLGY9bmV3IFVpbnQ4QXJyYXkoNCpkKTtmb3IobGV0IE09MDtNPGQ7KytNKXtjb25zdCB0PShpP01hdGguc3FydChjW01dKTpjW01dKS9uO28odCxmLDQqTSl9cmV0dXJuW2YsaCxzXX1leHBvcnR7ZSBhcyByYXN0ZXJpemVEYXNoLHIgYXMgcmFzdGVyaXplU2ltcGxlRmlsbH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yOC9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IHIgZnJvbVwiLi9zaGFkZXJSZXBvc2l0b3J5LmpzXCI7aW1wb3J0e1NoYWRlckNvbXBpbGVyIGFzIGV9ZnJvbVwiLi4vLi4vLi4vLi4vLi4vd2ViZ2wvU2hhZGVyQ29tcGlsZXIuanNcIjtmdW5jdGlvbiBvKGUpe2xldCBvPXI7cmV0dXJuIGUuc3BsaXQoXCIvXCIpLmZvckVhY2goKHI9PntvJiYobz1vW3JdKX0pKSxvfWNvbnN0IHQ9bmV3IGUobyk7ZnVuY3Rpb24gbihyKXtyZXR1cm4gdC5yZXNvbHZlSW5jbHVkZXMocil9ZXhwb3J0e24gYXMgcmVzb2x2ZUluY2x1ZGVzfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI4L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCBlPXtiYWNrZ3JvdW5kOntcImJhY2tncm91bmQuZnJhZ1wiOlwiI2lmZGVmIFBBVFRFUk5cXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfdGxicjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfaWQ7XFxuI2VuZGlmXFxudm9pZCBtYWluKCkge1xcbiNpZmRlZiBQQVRURVJOXFxubWVkaXVtcCB2ZWMyIG5vcm1hbGl6ZWRUZXh0dXJlQ29vcmQgPSBtb2Qodl90aWxlVGV4dHVyZUNvb3JkLCAxLjApO1xcbm1lZGl1bXAgdmVjMiBzYW1wbGVQb3MgPSBtaXgodl90bGJyLnh5LCB2X3RsYnIuencsIG5vcm1hbGl6ZWRUZXh0dXJlQ29vcmQpO1xcbmxvd3AgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHNhbXBsZVBvcyk7XFxuZ2xfRnJhZ0NvbG9yID0gdV9vcGFjaXR5ICogY29sb3I7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbmlmIChnbF9GcmFnQ29sb3IuYSA8IDEuMCAvIDI1NS4wKSB7XFxuZGlzY2FyZDtcXG59XFxuZ2xfRnJhZ0NvbG9yID0gdl9pZDtcXG4jZW5kaWZcXG59XCIsXCJiYWNrZ3JvdW5kLnZlcnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbiNpZmRlZiBJRFxcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2Nvb3JkX3JhbmdlO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2RlcHRoO1xcbiNpZmRlZiBQQVRURVJOXFxudW5pZm9ybSBtZWRpdW1wIG1hdDMgdV9wYXR0ZXJuX21hdHJpeDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgdV90bGJyO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbW9zYWljU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X3RsYnI7XFxuI2VuZGlmXFxudm9pZCBtYWluKCkge1xcbmdsX1Bvc2l0aW9uID0gdmVjNCgodV9kdnNNYXQzICogdmVjMyh1X2Nvb3JkX3JhbmdlICogYV9wb3MsIDEuMCkpLnh5LCB1X2RlcHRoLCAxLjApO1xcbiNpZmRlZiBQQVRURVJOXFxudl90aWxlVGV4dHVyZUNvb3JkID0gKHVfcGF0dGVybl9tYXRyaXggKiB2ZWMzKGFfcG9zLCAxLjApKS54eTtcXG52X3RsYnIgICAgICAgICAgICAgPSB1X3RsYnIgLyB1X21vc2FpY1NpemUueHl4eTtcXG4jZW5kaWZcXG4jaWZkZWYgSURcXG52X2lkID0gdV9pZCAvIDI1NS4wO1xcbiNlbmRpZlxcbn1cIn0sY2lyY2xlOntcImNpcmNsZS5mcmFnXCI6XCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfc3Ryb2tlX2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfc3Ryb2tlX3dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X29mZnNldDtcXG4jaWZkZWYgSURcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X2lkO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpXFxue1xcbm1lZGl1bXAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X29mZnNldCk7XFxubWVkaXVtcCBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoMC4wLCAtdl9ibHVyLCBkaXN0IC0gMS4wKTtcXG5sb3dwIGZsb2F0IGNvbG9yX21peF9yYXRpbyA9IHZfc3Ryb2tlX3dpZHRoIDwgMC4wMSA/IDAuMCA6IHNtb290aHN0ZXAoLXZfYmx1ciwgMC4wLCBkaXN0IC0gdl9yYWRpdXMgLyAodl9yYWRpdXMgKyB2X3N0cm9rZV93aWR0aCkpO1xcbmdsX0ZyYWdDb2xvciA9IGFscGhhICogbWl4KHZfY29sb3IsIHZfc3Ryb2tlX2NvbG9yLCBjb2xvcl9taXhfcmF0aW8pO1xcbiNpZmRlZiBJRFxcbmlmIChnbF9GcmFnQ29sb3IuYSA8IDEuMCAvIDI1NS4wKSB7XFxuZGlzY2FyZDtcXG59XFxuZ2xfRnJhZ0NvbG9yID0gdl9pZDtcXG4jZW5kaWZcXG59XCIsXCJjaXJjbGUudmVydFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuI3ByYWdtYSBoZWFkZXJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfc3Ryb2tlX2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfc3Ryb2tlX3dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X29mZnNldDtcXG4jaWZkZWYgSURcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCB1X2lkO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfaWQ7XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2NpcmNsZVRyYW5zbGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2RlcHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZ1dpZHRoO1xcbnZvaWQgbWFpbigpXFxue1xcbiNwcmFnbWEgbWFpblxcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxudl9zdHJva2VfY29sb3IgPSBzdHJva2VfY29sb3IgKiBzdHJva2Vfb3BhY2l0eTtcXG52X3N0cm9rZV93aWR0aCA9IHN0cm9rZV93aWR0aDtcXG52X3JhZGl1cyA9IHJhZGl1cztcXG52X2JsdXIgPSBtYXgoYmx1ciwgdV9hbnRpYWxpYXNpbmdXaWR0aCAvIChyYWRpdXMgKyBzdHJva2Vfd2lkdGgpKTtcXG5tZWRpdW1wIHZlYzIgb2Zmc2V0ID0gdmVjMihtb2QoYV9wb3MsIDIuMCkgKiAyLjAgLSAxLjApO1xcbnZfb2Zmc2V0ID0gb2Zmc2V0O1xcbiNpZmRlZiBJRFxcbnZfaWQgPSB1X2lkIC8gMjU1LjA7XFxuI2VuZGlmXFxubWVkaXVtcCB2ZWMzIHBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MgKiAwLjUsIDEuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMygodl9yYWRpdXMgKyB2X3N0cm9rZV93aWR0aCkgKiBvZmZzZXQgKyB1X2NpcmNsZVRyYW5zbGF0aW9uLCAwLjApO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIHVfZGVwdGgsIDEuMCk7XFxufVwifSxmaWxsOntcImZpbGwuZnJhZ1wiOlwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuI2lmZGVmIFBBVFRFUk5cXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl90bGJyO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfaWQ7XFxuI2VuZGlmXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG52ZWM0IG1peENvbG9ycyh2ZWM0IGNvbG9yMSwgdmVjNCBjb2xvcjIpIHtcXG5mbG9hdCBjb21wb3NpdGVBbHBoYSA9IGNvbG9yMi5hICsgY29sb3IxLmEgKiAoMS4wIC0gY29sb3IyLmEpO1xcbnZlYzMgY29tcG9zaXRlQ29sb3IgPSBjb2xvcjIucmdiICsgY29sb3IxLnJnYiAqICgxLjAgLSBjb2xvcjIuYSk7XFxucmV0dXJuIHZlYzQoY29tcG9zaXRlQ29sb3IsIGNvbXBvc2l0ZUFscGhhKTtcXG59XFxudm9pZCBtYWluKClcXG57XFxuI2lmZGVmIFBBVFRFUk5cXG5tZWRpdW1wIHZlYzIgbm9ybWFsaXplZFRleHR1cmVDb29yZCA9IGZyYWN0KHZfdGlsZVRleHR1cmVDb29yZCk7XFxubWVkaXVtcCB2ZWMyIHNhbXBsZVBvcyA9IG1peCh2X3RsYnIueHksIHZfdGxici56dywgbm9ybWFsaXplZFRleHR1cmVDb29yZCk7XFxubG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgc2FtcGxlUG9zKTtcXG5nbF9GcmFnQ29sb3IgPSB2X2NvbG9yWzNdICogY29sb3I7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbmlmIChnbF9GcmFnQ29sb3IuYSA8IDEuMCAvIDI1NS4wKSB7XFxuZGlzY2FyZDtcXG59XFxuZ2xfRnJhZ0NvbG9yID0gdl9pZDtcXG4jZW5kaWZcXG59XCIsXCJmaWxsLnZlcnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbiNwcmFnbWEgaGVhZGVyXFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2ZpbGxUcmFuc2xhdGlvbjtcXG4jaWZkZWYgUEFUVEVSTlxcbiNpbmNsdWRlIDx1dGlsL3V0aWwuZ2xzbD5cXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X21vc2FpY1NpemU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfcGF0dGVybkZhY3RvcjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl90bGJyO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZvaWQgbWFpbigpXFxue1xcbiNwcmFnbWEgbWFpblxcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxuI2lmZGVmIElEXFxudl9pZCA9IHVfaWQgLyAyNTUuMDtcXG4jZW5kaWZcXG4jaWZkZWYgUEFUVEVSTlxcbmZsb2F0IHBhdHRlcm5XaWR0aCA9IG5leHRQT1QodGxici56IC0gdGxici54KTtcXG5mbG9hdCBwYXR0ZXJuSGVpZ2h0ID0gbmV4dFBPVCh0bGJyLncgLSB0bGJyLnkpO1xcbmZsb2F0IHNjYWxlWCA9IDEuMCAvIChwYXR0ZXJuV2lkdGggKiB1X3BhdHRlcm5GYWN0b3IpO1xcbmZsb2F0IHNjYWxlWSA9IDEuMCAvIChwYXR0ZXJuSGVpZ2h0ICogdV9wYXR0ZXJuRmFjdG9yKTtcXG5tYXQzIHBhdHRlck1hdCA9IG1hdDMoc2NhbGVYLCAwLjAsICAgIDAuMCxcXG4wLjAsICAgIC1zY2FsZVksIDAuMCxcXG4wLjAsICAgIDAuMCwgICAgMS4wKTtcXG52X3RpbGVUZXh0dXJlQ29vcmQgPSAocGF0dGVyTWF0ICogdmVjMyhhX3BvcywgMS4wKSkueHk7XFxudl90bGJyICAgICAgICAgICAgID0gdGxiciAvIHVfbW9zYWljU2l6ZS54eXh5O1xcbiNlbmRpZlxcbnZlYzMgcG9zID0gdV9kdnNNYXQzICogdmVjMyhhX3BvcywgMS4wKSArIHVfZGlzcGxheU1hdDMgKiB2ZWMzKHVfZmlsbFRyYW5zbGF0aW9uLCAwLjApO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIHVfZGVwdGgsIDEuMCk7XFxufVwifSxpY29uOntcImljb24uZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuI2lmZGVmIFNERlxcbnVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBsb3dwIHZlYzQgdV9vdXRsaW5lQ29sb3I7XFxuI2VuZGlmXFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl90ZXg7XFxudmFyeWluZyBsb3dwIGZsb2F0IHZfb3BhY2l0eTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3NpemU7XFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jaWZkZWYgU0RGXFxudmFyeWluZyBtZWRpdW1wIGZsYW90IHZfaGFsb193aWR0aDtcXG4jZW5kaWZcXG4jaWZkZWYgSURcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X2lkO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDx1dGlsL2VuY29kaW5nLmdsc2w+XFxudmVjNCBtaXhDb2xvcnModmVjNCBjb2xvcjEsIHZlYzQgY29sb3IyKSB7XFxuZmxvYXQgY29tcG9zaXRlQWxwaGEgPSBjb2xvcjIuYSArIGNvbG9yMS5hICogKDEuMCAtIGNvbG9yMi5hKTtcXG52ZWMzIGNvbXBvc2l0ZUNvbG9yID0gY29sb3IyLnJnYiArIGNvbG9yMS5yZ2IgKiAoMS4wIC0gY29sb3IyLmEpO1xcbnJldHVybiB2ZWM0KGNvbXBvc2l0ZUNvbG9yLCBjb21wb3NpdGVBbHBoYSk7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbiNpZmRlZiBTREZcXG5sb3dwIHZlYzQgZmlsbFBpeGVsQ29sb3IgPSB2X2NvbG9yO1xcbmZsb2F0IGQgPSByZ2JhMmZsb2F0KHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KSkgLSAwLjU7XFxuY29uc3QgZmxvYXQgc29mdEVkZ2VSYXRpbyA9IDAuMjQ4MDYyMDE2O1xcbmZsb2F0IHNpemUgPSBtYXgodl9zaXplLngsIHZfc2l6ZS55KTtcXG5mbG9hdCBkaXN0ID0gZCAqIHNvZnRFZGdlUmF0aW8gKiBzaXplO1xcbmZpbGxQaXhlbENvbG9yICo9IGNsYW1wKDAuNSAtIGRpc3QsIDAuMCwgMS4wKTtcXG5pZiAodl9oYWxvX3dpZHRoID4gMC4yNSkge1xcbmxvd3AgdmVjNCBvdXRsaW5lUGl4ZWxDb2xvciA9IHVfb3V0bGluZUNvbG9yO1xcbmNvbnN0IGZsb2F0IG91dGxpbmVMaW1pdFJhdGlvID0gKDE2LjAgLyA4Ni4wKTtcXG5mbG9hdCBjbGFtcGVkT3V0bGluZVNpemUgPSBzb2Z0RWRnZVJhdGlvICogbWluKHZfaGFsb193aWR0aCwgb3V0bGluZUxpbWl0UmF0aW8gKiBtYXgodl9zaXplLngsIHZfc2l6ZS55KSk7XFxub3V0bGluZVBpeGVsQ29sb3IgKj0gY2xhbXAoMC41IC0gKGFicyhkaXN0KSAtIGNsYW1wZWRPdXRsaW5lU2l6ZSksIDAuMCwgMS4wKTtcXG5nbF9GcmFnQ29sb3IgPSB2X29wYWNpdHkgKiBtaXhDb2xvcnMoZmlsbFBpeGVsQ29sb3IsIG91dGxpbmVQaXhlbENvbG9yKTtcXG59XFxuZWxzZSB7XFxuZ2xfRnJhZ0NvbG9yID0gdl9vcGFjaXR5ICogZmlsbFBpeGVsQ29sb3I7XFxufVxcbiNlbHNlXFxubG93cCB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpO1xcbmdsX0ZyYWdDb2xvciA9IHZfb3BhY2l0eSAqIHRleENvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbmlmIChnbF9GcmFnQ29sb3IuYSA8IDEuMCAvIDI1NS4wKSB7XFxuZGlzY2FyZDtcXG59XFxuZ2xfRnJhZ0NvbG9yID0gdl9pZDtcXG4jZW5kaWZcXG59XCIsXCJpY29uLnZlcnRcIjpcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4T2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGV4QW5nbGVSYW5nZTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2xldmVsSW5mbztcXG5hdHRyaWJ1dGUgZmxvYXQgYV9vcGFjaXR5SW5mbztcXG4jcHJhZ21hIGhlYWRlclxcbiNpZmRlZiBJRFxcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbiNpZmRlZiBTREZcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9oYWxvX3dpZHRoO1xcbiNlbmRpZlxcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2R2c01hdDM7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZGlzcGxheU1hdDM7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZGlzcGxheVZpZXdNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfaWNvblRyYW5zbGF0aW9uO1xcbnVuaWZvcm0gdmVjMiB1X21vc2FpY1NpemU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZGVwdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfbWFwUm90YXRpb247XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfbGV2ZWw7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfa2VlcFVwcmlnaHQ7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZmFkZUR1cmF0aW9uO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgbG93cCBmbG9hdCB2X29wYWNpdHk7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9zaXplO1xcbmNvbnN0IGZsb2F0IENfT0ZGU0VUX1BSRUNJU0lPTiA9IDEuMCAvIDguMDtcXG5jb25zdCBmbG9hdCBDXzI1Nl9UT19SQUQgPSAzLjE0MTU5MjY1MzU5IC8gMTI4LjA7XFxuY29uc3QgZmxvYXQgQ19ERUdfVE9fUkFEID0gMy4xNDE1OTI2NTM1OSAvIDE4MC4wO1xcbmNvbnN0IGZsb2F0IHRpbGVDb29yZFJhdGlvID0gMS4wIC8gOC4wO1xcbnVuaWZvcm0gaGlnaHAgZmxvYXQgdV90aW1lO1xcbnZvaWQgbWFpbigpXFxue1xcbiNwcmFnbWEgbWFpblxcbnZfY29sb3IgPSBjb2xvcjtcXG52X29wYWNpdHkgPSBvcGFjaXR5O1xcbiNpZmRlZiBTREZcXG52X2hhbG9fd2lkdGggPSBoYWxvX3dpZHRoO1xcbiNlbmRpZlxcbmZsb2F0IG1vZGRlZCA9IG1vZChhX29wYWNpdHlJbmZvLCAxMjguMCk7XFxuZmxvYXQgdGFyZ2V0T3BhY2l0eSA9IChhX29wYWNpdHlJbmZvIC0gbW9kZGVkKSAvIDEyOC4wO1xcbmZsb2F0IHN0YXJ0T3BhY2l0eSA9IG1vZGRlZCAvIDEyNy4wO1xcbmZsb2F0IGludGVycG9sYXRlZE9wYWNpdHkgPSBjbGFtcChzdGFydE9wYWNpdHkgKyAyLjAgKiAodGFyZ2V0T3BhY2l0eSAtIDAuNSkgKiB1X3RpbWUgLyB1X2ZhZGVEdXJhdGlvbiwgMC4wLCAxLjApO1xcbnZfb3BhY2l0eSAqPSBpbnRlcnBvbGF0ZWRPcGFjaXR5O1xcbm1lZGl1bXAgZmxvYXQgYV9hbmdsZSAgICAgICAgID0gYV9sZXZlbEluZm9bMV07XFxubWVkaXVtcCBmbG9hdCBhX21pbkxldmVsICAgICAgPSBhX2xldmVsSW5mb1syXTtcXG5tZWRpdW1wIGZsb2F0IGFfbWF4TGV2ZWwgICAgICA9IGFfbGV2ZWxJbmZvWzNdO1xcbm1lZGl1bXAgdmVjMiBhX3RleCAgICAgICAgICAgID0gYV90ZXhBbmdsZVJhbmdlLnh5O1xcbm1lZGl1bXAgZmxvYXQgZGVsdGFfeiA9IDAuMDtcXG5tZWRpdW1wIGZsb2F0IHJvdGF0ZWQgPSBtb2QoYV9hbmdsZSArIHVfbWFwUm90YXRpb24sIDI1Ni4wKTtcXG5kZWx0YV96ICs9ICgxLjAgLSBzdGVwKHVfa2VlcFVwcmlnaHQsIDAuMCkpICogc3RlcCg2NC4wLCByb3RhdGVkKSAqICgxLjAgLSBzdGVwKDE5Mi4wLCByb3RhdGVkKSk7XFxuZGVsdGFfeiArPSAxLjAgLSBzdGVwKGFfbWluTGV2ZWwsIHVfbGV2ZWwpO1xcbmRlbHRhX3ogKz0gc3RlcChhX21heExldmVsLCB1X2xldmVsKTtcXG5kZWx0YV96ICs9IHN0ZXAodl9vcGFjaXR5LCAwLjApO1xcbnZlYzIgb2Zmc2V0ID0gQ19PRkZTRVRfUFJFQ0lTSU9OICogYV92ZXJ0ZXhPZmZzZXQ7XFxudl9zaXplID0gYWJzKG9mZnNldCk7XFxuI2lmZGVmIFNERlxcbm9mZnNldCA9ICgxMjAuMCAvIDg2LjApICogb2Zmc2V0O1xcbiNlbmRpZlxcbm1lZGl1bXAgdmVjMyBwb3MgPSB1X2R2c01hdDMgKiB2ZWMzKGFfcG9zLCAxLjApICsgdV9kaXNwbGF5Vmlld01hdDMgKiB2ZWMzKHNpemUgKiBvZmZzZXQsIDAuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyh1X2ljb25UcmFuc2xhdGlvbiwgMC4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCB1X2RlcHRoICsgZGVsdGFfeiwgMS4wKTtcXG4jaWZkZWYgSURcXG52X2lkID0gdV9pZCAvIDI1NS4wO1xcbiNlbmRpZlxcbnZfdGV4ID0gYV90ZXgueHkgLyB1X21vc2FpY1NpemU7XFxufVwifSxsaW5lOntcImxpbmUuZnJhZ1wiOlwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBoaWdocCBmbG9hdCB2X2FjY3VtdWxhdGVkRGlzdGFuY2U7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfbGluZUhhbGZXaWR0aDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfdGxicjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3BhdHRlcm5TaXplO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3dpZHRoUmF0aW87XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZztcXG4jZW5kaWZcXG4jaWZkZWYgU0RGXFxuI2luY2x1ZGUgPHV0aWwvZW5jb2RpbmcuZ2xzbD5cXG4jZW5kaWZcXG4jaWZkZWYgSURcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X2lkO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpXFxue1xcbm1lZGl1bXAgZmxvYXQgZnJhZ0Rpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdl9saW5lSGFsZldpZHRoO1xcbmxvd3AgZmxvYXQgYWxwaGEgPSBjbGFtcCgodl9saW5lSGFsZldpZHRoIC0gZnJhZ0Rpc3QpIC8gdl9ibHVyLCAwLjAsIDEuMCk7XFxuI2lmZGVmIFBBVFRFUk5cXG5tZWRpdW1wIGZsb2F0IHJlbGF0aXZlVGV4WCA9IGZyYWN0KHZfYWNjdW11bGF0ZWREaXN0YW5jZSAvICh2X3BhdHRlcm5TaXplLnggKiB2X3dpZHRoUmF0aW8pKTtcXG5tZWRpdW1wIGZsb2F0IHJlbGF0aXZlVGV4WSA9IDAuNSArIHZfbm9ybWFsLnkgKiB2X2xpbmVIYWxmV2lkdGggLyAodl9wYXR0ZXJuU2l6ZS55ICogdl93aWR0aFJhdGlvKTtcXG5tZWRpdW1wIHZlYzIgdGV4Q29vcmQgPSBtaXgodl90bGJyLnh5LCB2X3RsYnIuencsIHZlYzIocmVsYXRpdmVUZXhYLCByZWxhdGl2ZVRleFkpKTtcXG5sb3dwIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB0ZXhDb29yZCk7XFxuZ2xfRnJhZ0NvbG9yID0gYWxwaGEgKiB2X2NvbG9yWzNdICogY29sb3I7XFxuI2VsaWYgZGVmaW5lZChTREYpXFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFggPSBmcmFjdCgodl9hY2N1bXVsYXRlZERpc3RhbmNlICogMC41KSAvICh2X3BhdHRlcm5TaXplLnggKiB2X3dpZHRoUmF0aW8pKTtcXG5tZWRpdW1wIGZsb2F0IHJlbGF0aXZlVGV4WSA9ICAwLjUgKyAwLjI1ICogdl9ub3JtYWwueTtcXG5tZWRpdW1wIHZlYzIgdGV4Q29vcmQgPSBtaXgodl90bGJyLnh5LCB2X3RsYnIuencsIHZlYzIocmVsYXRpdmVUZXhYLCByZWxhdGl2ZVRleFkpKTtcXG5tZWRpdW1wIGZsb2F0IGQgPSByZ2JhMmZsb2F0KHRleHR1cmUyRCh1X3RleHR1cmUsIHRleENvb3JkKSkgLSAwLjU7XFxuZmxvYXQgZGlzdCA9IGQgKiAodl9saW5lSGFsZldpZHRoICsgdV9hbnRpYWxpYXNpbmcgLyAyLjApO1xcbmdsX0ZyYWdDb2xvciA9IGFscGhhICogY2xhbXAoMC41IC0gZGlzdCwgMC4wLCAxLjApICogdl9jb2xvcjtcXG4jZWxzZVxcbmdsX0ZyYWdDb2xvciA9IGFscGhhICogdl9jb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgSURcXG5pZiAoZ2xfRnJhZ0NvbG9yLmEgPCAxLjAgLyAyNTUuMCkge1xcbmRpc2NhcmQ7XFxufVxcbmdsX0ZyYWdDb2xvciA9IHZfaWQ7XFxuI2VuZGlmXFxufVwiLFwibGluZS52ZXJ0XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjNCBhX2V4dHJ1ZGVfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGlyX25vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiBhX2FjY3VtdWxhdGVkRGlzdGFuY2U7XFxuI3ByYWdtYSBoZWFkZXJcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlWaWV3TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV96b29tRmFjdG9yO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbGluZVRyYW5zbGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IHZfYWNjdW11bGF0ZWREaXN0YW5jZTtcXG5jb25zdCBmbG9hdCBzY2FsZSA9IDEuMCAvIDMxLjA7XFxuY29uc3QgbWVkaXVtcCBmbG9hdCB0aWxlQ29vcmRSYXRpbyA9IDguMDtcXG4jaWYgZGVmaW5lZCAoU0RGKVxcbmNvbnN0IG1lZGl1bXAgZmxvYXQgc2RmUGF0dGVybkhhbGZXaWR0aCA9IDE1LjU7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbW9zYWljU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X3RsYnI7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9wYXR0ZXJuU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl93aWR0aFJhdGlvO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2xpbmVIYWxmV2lkdGg7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfYmx1cjtcXG52b2lkIG1haW4oKVxcbntcXG4jcHJhZ21hIG1haW5cXG52X2NvbG9yID0gY29sb3IgKiBvcGFjaXR5O1xcbnZfYmx1ciA9IGJsdXIgKyB1X2FudGlhbGlhc2luZztcXG52X25vcm1hbCA9IGFfZGlyX25vcm1hbC56dyAqIHNjYWxlO1xcbiNpZiBkZWZpbmVkIChQQVRURVJOKSB8fCBkZWZpbmVkKFNERilcXG52X3RsYnIgICAgICAgICAgPSB0bGJyIC8gdV9tb3NhaWNTaXplLnh5eHk7XFxudl9wYXR0ZXJuU2l6ZSAgID0gdmVjMih0bGJyLnogLSB0bGJyLngsIHRsYnIueSAtIHRsYnIudyk7XFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pXFxudl93aWR0aFJhdGlvID0gd2lkdGggLyB2X3BhdHRlcm5TaXplLnk7XFxuI2Vsc2VcXG52X3dpZHRoUmF0aW8gPSB3aWR0aCAvIHNkZlBhdHRlcm5IYWxmV2lkdGggLyAyLjA7XFxuI2VuZGlmXFxuI2VuZGlmXFxudl9saW5lSGFsZldpZHRoID0gKHdpZHRoICsgdV9hbnRpYWxpYXNpbmcpICogMC41O1xcbm1lZGl1bXAgdmVjMiBkaXIgPSBhX2Rpcl9ub3JtYWwueHkgKiBzY2FsZTtcXG5tZWRpdW1wIHZlYzIgb2Zmc2V0XyA9IGFfZXh0cnVkZV9vZmZzZXQuencgKiBzY2FsZSAqIG9mZnNldDtcXG5tZWRpdW1wIHZlYzIgZGlzdCA9IHZfbGluZUhhbGZXaWR0aCAqIHNjYWxlICogYV9leHRydWRlX29mZnNldC54eTtcXG5tZWRpdW1wIHZlYzMgcG9zID0gdV9kdnNNYXQzICogdmVjMyhhX3BvcyArIG9mZnNldF8gKiB0aWxlQ29vcmRSYXRpbyAvIHVfem9vbUZhY3RvciwgMS4wKSArIHVfZGlzcGxheVZpZXdNYXQzICogdmVjMyhkaXN0LCAwLjApICsgdV9kaXNwbGF5TWF0MyAqIHZlYzModV9saW5lVHJhbnNsYXRpb24sIDAuMCk7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgdV9kZXB0aCwgMS4wKTtcXG4jaWYgZGVmaW5lZCAoUEFUVEVSTikgfHwgZGVmaW5lZChTREYpXFxudl9hY2N1bXVsYXRlZERpc3RhbmNlID0gYV9hY2N1bXVsYXRlZERpc3RhbmNlLnggKiB1X3pvb21GYWN0b3IgLyB0aWxlQ29vcmRSYXRpbyArIGRvdChkaXIsIGRpc3QgKyBvZmZzZXRfKTtcXG4jZW5kaWZcXG4jaWZkZWYgSURcXG52X2lkID0gdV9pZCAvIDI1NS4wO1xcbiNlbmRpZlxcbn1cIn0sb3V0bGluZTp7XCJvdXRsaW5lLmZyYWdcIjpcInZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9ub3JtYWw7XFxuI2lmZGVmIElEXFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG5sb3dwIGZsb2F0IGRpc3QgPSBhYnModl9ub3JtYWwueSk7XFxubG93cCBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoMS4wLCAwLjAsIGRpc3QpO1xcbmdsX0ZyYWdDb2xvciA9IGFscGhhICogdl9jb2xvcjtcXG4jaWZkZWYgSURcXG5pZiAoZ2xfRnJhZ0NvbG9yLmEgPCAxLjAgLyAyNTUuMCkge1xcbmRpc2NhcmQ7XFxufVxcbmdsX0ZyYWdDb2xvciA9IHZfaWQ7XFxuI2VuZGlmXFxufVwiLFwib3V0bGluZS52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3hub3JtYWw7XFxuI3ByYWdtYSBoZWFkZXJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbiNpZmRlZiBJRFxcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfZmlsbFRyYW5zbGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2RlcHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X291dGxpbmVfd2lkdGg7XFxudmFyeWluZyBsb3dwIHZlYzIgdl9ub3JtYWw7XFxuY29uc3QgZmxvYXQgc2NhbGUgPSAxLjAgLyAxNS4wO1xcbnZvaWQgbWFpbigpXFxue1xcbiNwcmFnbWEgbWFpblxcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxuI2lmZGVmIElEXFxudl9pZCA9IHVfaWQgLyAyNTUuMDtcXG4jZW5kaWZcXG52X25vcm1hbCA9IGFfeG5vcm1hbDtcXG5tZWRpdW1wIHZlYzIgZGlzdCA9IHVfb3V0bGluZV93aWR0aCAqIHNjYWxlICogYV9vZmZzZXQ7XFxubWVkaXVtcCB2ZWMzIHBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MsIDEuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyhkaXN0ICsgdV9maWxsVHJhbnNsYXRpb24sIDAuMCk7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgdV9kZXB0aCwgMS4wKTtcXG59XCJ9LHRleHQ6e1widGV4dC5mcmFnXCI6XCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIGxvd3AgdmVjMiB2X3RleDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2VkZ2VXaWR0aDtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9lZGdlRGlzdGFuY2U7XFxuI2lmZGVmIElEXFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl9pZDtcXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG5sb3dwIGZsb2F0IGRpc3QgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleCkuYTtcXG5tZWRpdW1wIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCh2X2VkZ2VEaXN0YW5jZSAtIHZfZWRnZVdpZHRoLCB2X2VkZ2VEaXN0YW5jZSArIHZfZWRnZVdpZHRoLCBkaXN0KTtcXG5nbF9GcmFnQ29sb3IgPSBhbHBoYSAqIHZfY29sb3I7XFxuI2lmZGVmIElEXFxuaWYgKGdsX0ZyYWdDb2xvci5hIDwgMS4wIC8gMjU1LjApIHtcXG5kaXNjYXJkO1xcbn1cXG5nbF9GcmFnQ29sb3IgPSB2X2lkO1xcbiNlbmRpZlxcbn1cIixcInRleHQudmVydFwiOlwiYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXhPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV90ZXhBbmdsZVJhbmdlO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfbGV2ZWxJbmZvO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX29wYWNpdHlJbmZvO1xcbiNwcmFnbWEgaGVhZGVyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jaWZkZWYgSURcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCB1X2lkO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfaWQ7XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5TWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5Vmlld01hdDM7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV90ZXh0VHJhbnNsYXRpb247XFxudW5pZm9ybSB2ZWMyIHVfbW9zYWljU2l6ZTtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9tYXBSb3RhdGlvbjtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9sZXZlbDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9rZWVwVXByaWdodDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9mYWRlRHVyYXRpb247XFxudmFyeWluZyBsb3dwIHZlYzIgdl90ZXg7XFxuY29uc3QgZmxvYXQgb2Zmc2V0UHJlY2lzaW9uID0gMS4wIC8gOC4wO1xcbmNvbnN0IG1lZGl1bXAgZmxvYXQgZWRnZVBvcyA9IDAuNzU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfYW50aWFsaWFzaW5nV2lkdGg7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfZWRnZURpc3RhbmNlO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2VkZ2VXaWR0aDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9oYWxvO1xcbmNvbnN0IGZsb2F0IHNkZkZvbnRTY2FsZSA9IDEuMCAvIDI0LjA7XFxuY29uc3QgZmxvYXQgc2RmUGl4ZWwgPSAzLjA7XFxudW5pZm9ybSBoaWdocCBmbG9hdCB1X3RpbWU7XFxudm9pZCBtYWluKClcXG57XFxuI3ByYWdtYSBtYWluXFxuaWYgKHVfaGFsbyA+IDAuNSlcXG57XFxudl9jb2xvciA9IGhhbG9fY29sb3IgKiBvcGFjaXR5O1xcbmhhbG9fd2lkdGggKj0gc2RmUGl4ZWw7XFxuaGFsb19ibHVyICo9IHNkZlBpeGVsO1xcbn1cXG5lbHNlXFxue1xcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxuaGFsb193aWR0aCA9IDAuMDtcXG5oYWxvX2JsdXIgPSAwLjA7XFxufVxcbmZsb2F0IG1vZGRlZCA9IG1vZChhX29wYWNpdHlJbmZvLCAxMjguMCk7XFxuZmxvYXQgdGFyZ2V0T3BhY2l0eSA9IChhX29wYWNpdHlJbmZvIC0gbW9kZGVkKSAvIDEyOC4wO1xcbmZsb2F0IHN0YXJ0T3BhY2l0eSA9IG1vZGRlZCAvIDEyNy4wO1xcbmZsb2F0IGludGVycG9sYXRlZE9wYWNpdHkgPSBjbGFtcChzdGFydE9wYWNpdHkgKyAyLjAgKiAodGFyZ2V0T3BhY2l0eSAtIDAuNSkgKiB1X3RpbWUgLyB1X2ZhZGVEdXJhdGlvbiwgMC4wLCAxLjApO1xcbnZfY29sb3IgKj0gaW50ZXJwb2xhdGVkT3BhY2l0eTtcXG5tZWRpdW1wIGZsb2F0IGFfYW5nbGUgICAgICAgPSBhX2xldmVsSW5mb1sxXTtcXG5tZWRpdW1wIGZsb2F0IGFfbWluTGV2ZWwgICAgPSBhX2xldmVsSW5mb1syXTtcXG5tZWRpdW1wIGZsb2F0IGFfbWF4TGV2ZWwgICAgPSBhX2xldmVsSW5mb1szXTtcXG5tZWRpdW1wIHZlYzIgYV90ZXggICAgICAgICAgPSBhX3RleEFuZ2xlUmFuZ2UueHk7XFxubWVkaXVtcCBmbG9hdCBhX3Zpc01pbkFuZ2xlICAgID0gYV90ZXhBbmdsZVJhbmdlLno7XFxubWVkaXVtcCBmbG9hdCBhX3Zpc01heEFuZ2xlICAgID0gYV90ZXhBbmdsZVJhbmdlLnc7XFxubWVkaXVtcCBmbG9hdCBkZWx0YV96ID0gMC4wO1xcbm1lZGl1bXAgZmxvYXQgYW5nbGUgPSBtb2QoYV9hbmdsZSArIHVfbWFwUm90YXRpb24sIDI1Ni4wKTtcXG5pZiAoYV92aXNNaW5BbmdsZSA8IGFfdmlzTWF4QW5nbGUpXFxue1xcbmRlbHRhX3ogKz0gKDEuMCAtIHN0ZXAodV9rZWVwVXByaWdodCwgMC4wKSkgKiAoc3RlcChhX3Zpc01heEFuZ2xlLCBhbmdsZSkgKyAoMS4wIC0gc3RlcChhX3Zpc01pbkFuZ2xlLCBhbmdsZSkpKTtcXG59XFxuZWxzZVxcbntcXG5kZWx0YV96ICs9ICgxLjAgLSBzdGVwKHVfa2VlcFVwcmlnaHQsIDAuMCkpICogKHN0ZXAoYV92aXNNYXhBbmdsZSwgYW5nbGUpICogKDEuMCAtIHN0ZXAoYV92aXNNaW5BbmdsZSwgYW5nbGUpKSk7XFxufVxcbmRlbHRhX3ogKz0gMS4wIC0gc3RlcChhX21pbkxldmVsLCB1X2xldmVsKTtcXG5kZWx0YV96ICs9IHN0ZXAoYV9tYXhMZXZlbCwgdV9sZXZlbCk7XFxuZGVsdGFfeiArPSBzdGVwKHZfY29sb3JbM10sIDAuMCk7XFxudl90ZXggPSBhX3RleC54eSAvIHVfbW9zYWljU2l6ZTtcXG4jaWZkZWYgSURcXG52X2lkID0gdV9pZCAvIDI1NS4wO1xcbiNlbmRpZlxcbnZfZWRnZURpc3RhbmNlID0gZWRnZVBvcyAtIGhhbG9fd2lkdGggLyBzaXplO1xcbnZfZWRnZVdpZHRoID0gKHVfYW50aWFsaWFzaW5nV2lkdGggKyBoYWxvX2JsdXIpIC8gc2l6ZTtcXG5tZWRpdW1wIHZlYzMgcG9zID0gdV9kdnNNYXQzICogdmVjMyhhX3BvcywgMS4wKSArIHNkZkZvbnRTY2FsZSAqIHVfZGlzcGxheVZpZXdNYXQzICogdmVjMyhvZmZzZXRQcmVjaXNpb24gKiBzaXplICogYV92ZXJ0ZXhPZmZzZXQsIDAuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyh1X3RleHRUcmFuc2xhdGlvbiwgMC4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCB1X2RlcHRoICsgZGVsdGFfeiwgMS4wKTtcXG59XCJ9LHV0aWw6e1wiZW5jb2RpbmcuZ2xzbFwiOlwiY29uc3QgdmVjNCByZ2JhMmZsb2F0X2ZhY3RvcnMgPSB2ZWM0KFxcbjI1NS4wIC8gKDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wICogMjU2LjApLFxcbjI1NS4wIC8gKDI1Ni4wICogMjU2LjAgKiAyNTYuMCAqIDI1Ni4wKVxcbik7XFxuZmxvYXQgcmdiYTJmbG9hdCh2ZWM0IHJnYmEpIHtcXG5yZXR1cm4gZG90KHJnYmEsIHJnYmEyZmxvYXRfZmFjdG9ycyk7XFxufVwiLFwidXRpbC5nbHNsXCI6XCJmbG9hdCBuZXh0UE9UKGluIGZsb2F0IHgpIHtcXG5yZXR1cm4gcG93KDIuMCwgY2VpbChsb2cyKGFicyh4KSkpKTtcXG59XCJ9fTtleHBvcnR7ZSBhcyBkZWZhdWx0fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==